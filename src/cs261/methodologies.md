# Requirements & Software Methodologies

- Formal guidelines on how software should be engineered
- Software process model is a sequence of activities that leads to the production of a software product
  - Specification - what software should do
  - Design and implementation - how should be organised and implemented
  - Validation and testing - does it do what it should
  - Software evolution - changing software over time
- Plan driven
  - All activities planned in advance
  - Progress measured against plan
  - Fixed, detailed spec before development commences
- Agile
  - Incremental planning
  - More adaptable to change

## Plan-Based Methodologies

- Waterfall model has a strict linear ordering of processes
  - Each stage must be completed before moving on
  - If anything changes in the plan, go back to the start again
  - Stages:
    - Requirements analysis
      - System's services, constraints, goals are established and defined
    - System design
      - Identification of software components and their relationships
    - Implementation and unit testing
      - Software programmed in unit, each unit tested against specification
    - Integration and system testing
      - Software components integrated and tested together as a complete system
    - Operation and maintenance
      - System installed, any errors that appear are fixed
      - System services enhanced as new requirements added
  - Works if requirements are fixed an understood
  - Fewer team constraints
  - Each component can be tested against spec
  - Easy to churn team because everything well-documented
  - Customers can wait a long time for results
  - Difficult to accommodate change
  - Difficult to respond to changing requirements
  - Can be a problem if project is long running
    - Longer time = more likelihood of things changing
- Plan driven too rigid - introduce flexibility with incremental development
  - Develop in staged with customer feedback incorporated between iterations
  - Specification - development - validation is iterative
  - New functionality can be added in each iteration
  - Each stage planned in full and validated against plan
  - Cost of accommodating change is reduced
  - Software available to use quicker so feedback can be gathered easily
  - Customers can see development in progress
  - Easier to include user acceptance testing
  - Difficult to estimate cost of development
  - Difficult to maintain consistency
  - As progress continues, becomes harder to include new features or make changes
  - Not cost effective to document each version
  - Increased cost of repeated deployment
- Re-writing software from scratch is expensive
  - Rely instead on off the shelf components (libraries, frameworks)
  - Include component analysis in development flow, identify library/framework
  - Requirements may have to accommodate available components

## Agile Methodologies

- Agile development is a principle that defines a set of methodologies
  - Interleaves specification, design and implementation
  - System developed as a series of versions
  - Feedback provided at each stage
  - Process driven approaches have become too cumbersome as businesses need to be able to evolve more rapidly
    - Increased focus on code over design
  - Principles include
    - Customer involvement
    - Incremental delivery
    - People, not process
    - Embrace change
    - Maintain simplicity
  - Focuses on development over documentation - can make it hard to pick up a system later on
  - Works well as long as original team continues the evolution - problems can arise if team changes
- Possible to use techniques from both plan-based and agile, depending on what is applicable
- Extreme programming is an agile methodology involving incremental delivery with fast iteration
  - Build several times a day
  - Deliver to customers often
  - Automate tests to verify builds
  - Strong customer involvement
  - Incremental planning with requirements on story cards, stories selected based on priority
  - Small releases with initially minimal functionality, then building with more
  - Simple design, only enough to meet current requirements
  - Write tests before the software - test driven
  - Developers expected to continually refactor code
  - Pair programming provides support
  - Collective code ownership allows for anyone to work on anything
  - Continuous Integration integrates components as soon as they are ready
  - Working at a sustainable pace is important for developers
  - Having customer on-site is useful to incorporate frequent feedback
- Scrum is a general agile method that focuses on managing iterative development
  - 3 primary stages:
    - Outline planning phase to establish general goals
    - Sprint cycles, each cycle developing an increment of the system
    - Project closure, wrap up project, document, deliver
  - Uses quick development cycles of typically 2-4 weeks
    - Daily team meetings to discuss current work
    - Each sprint completes item on backlog
    - Features selected with customer
    - Scrum master interface between team and customer
    - End of each sprint, work reviewed and presented

## Requirements Analysis

- Requirements are descriptions of what the system should and should not do, the service it provides, and the constraints on its operation
- Enable developers to make software that will correctly fulfil customers needs
- Provides a basis for tests, validation and verification
- Enable (semi-)cost accurate specification
- Important to distinguish what is built from how it is built
- Requirements act as a bridge between customers and developers
- First stage in any process is software specification - requirements engineering
  - Requires that we define the services required from the system
  - Identify constraints on operation and development
  - Produce a requirements document
    - End user facing and system developer facing - possibly two documents
  - Feasibility study determines that task is feasible and cost effective
  - Requirements elicitation and analysis derives the system requirements
    - Look at existing docs
    - Talk to customer
    - Discuss features
    - Possibly prototype
  - Requirements specification translates information gathered in elicitation into formal documents
  - Requirements validation ensures requirements are achievable and valid
  - Need to ensure customer signs off requirements
  - Notion of C- and D-requirements for customer and development facing
    - Technical requirements vs idiot speak
    - C-requirements describe operation and constraints from users's point of view
    - D-facing give detailed description of system functions, acting as basis for contract with developer
- Good requirements are
  - Prioritised: features have an implementation priority
  - Consistent: requirements do not conflict with each other
  - Modifiable: able to revise set of requirements when necessary and maintain history of changes
  - Traceable: able to link each requirement to source, which could be higher-level requirement, use case, or customer statement
  - Correct: accurately describes functionality to be delivered
  - Feasible: must be possible to implement each requirement within the known capabilities and limitations of environment
  - Necessary: should document something that customers actually need, or is required for conformance to external standard or interface
  - Unambiguous: someone reading requirement should interpret it only one way
  - Verifiable: can tests or other approaches be used to verify if requirement has been implemented properly
- MoSCoW requirements group requirements into 4 groups:
  - Must have
  - Should have
  - Could have
  - Won't have
- Requirements document will be read by:
  - Customers
  - Managers
  - Engineers
  - Testers
  - Maintainers
- Sections include:
  - Preface - history and purpose of document
  - Intro - justify and outline system
  - Glossary
  - User requirements design - describe services provided for users
  - System architecture - high-level overview of system
  - Requirements spec - describe functional and non-functional requirements
  - System models - show relationships between system components
  - System evolution - anticipated changes due to changing future needs
- Functional requirements describe what system should do, state system services and how it should behave in different scenarios
- Non-functional requirements are constraints on services or functions offered by system, describe qualities of the system such as availability, performance, etc
- Requirements engineering processes is not a linear sequence, processes often interleaved and iterated upon
  - Requirements discovery
    - Gather info from stakeholders
    - Domain research
    - Consider use cases
  - Classification and organisation - group similar requirements and organise into categories
  - Prioritisation and negotiation - assign priorities and sort conflicts between requirements from different stakeholders
  - Specification - write the document and give to stakeholders, then iterate
- Requirements validation is key once document has been written
  - Validity - will system support customer's needs?
  - Consistency - are there any conflicts?
  - Realism - can system be produced with available resources and technology?
  - Verifiability - can system be shown/proved to satisfy requirements?
  - Review by both customers and engineers
  - Prototyping and test-case generation
- Requirements must be managed to see if they should be accepted
  - Problem analysis - is new requirement valid and unambiguous?
  - Change analysis - what are the effects on the rest of the system?
  - Change implementation - do the change
- Must take into account legal, social, ethical, professional issues
  - Copyright
  - Patents
  - Developers given fair recognition of work
  - Software not produced to do anything illegal or evil
  - Work completed in best interest of customer

